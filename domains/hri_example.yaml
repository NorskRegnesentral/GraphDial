db_host: tagtog.nr.no
db_port: 7687
zmq_input_port: 5555
zmq_output_port: 5556

inputs:
  - HumanUtterance
  - HumanEngagement
outputs:
  - RobotUtterance
  - RobotAction

initial_state: >
  CREATE (f:Floor {status: 'free'}) ;

update_rules: "
MATCH (i:Intent),
(i)-[e:inferred_from]->(asr:ASRHypothesis)
WITH i, sum(e.condprob * asr.prob) as prob
SET i.marginal_prob=prob;

MATCH (u:HumanUtterance)-[:alternative]->(h:ASRHypothesis)
CALL rasa_nlu.run(h.transcript) YIELD intents, entities 
UNWIND intents as intent
CREATE (i:Intent {name:intent.name, prob:intent.prob})-[:INFERRED_FROM]->(h)
WITH entities, h, i
UNWIND entities as entity
CREATE (em:EntityMention {name:entity.value, prob:entity.prob, start:entity.start, end:entity.end})-[:INFERRED_FROM]->(h)
CREATE (i)<-[:MENTIONED_IN]-(em); 

MATCH (i:Intent {name: 'greet'})
MERGE (r:RobotUtterance {name: 'Hello, my name is Pepper!'})<-[:INFERRED_FROM {util: 5}]-(i);

MATCH (em: EntityMention)-[r:MENTIONED_IN]->(i: Intent)
WHERE degree(em) > 2
MERGE (cr:CandidateResponse {name: 'DisambiguateEntity'})-[:INFERRED_FROM {util: 10}]->(i);

MATCH (em: EntityMention)-[r:MENTIONED_IN]->(i: Intent)
WHERE degree(em) < 2
MERGE (cr:CandidateResponse {name: 'EntityNotFound'})-[:INFERRED_FROM {util: 10}]->(i);

MATCH (i:Intent {name: 'request_person_availability'})<-[:MENTIONED_IN]-(pm:EntityMention {entity: 'person'})
MATCH (pm)-[:REFERS_TO]->(p:Person {name: pm.value})
OPTIONAL MATCH (p)<-[:HAS_PARTICIPANT]-(e:Event)
OPTIONAL MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE st.time < timestamp() AND timestamp() < et.time
WITH i, p, count(e) as c1, count(st) as c2
WHERE c1=0 or c2=0
MERGE (cr:CandidateResponse {name: 'InformPersonIsAvailable'})-[:ARG_OF]->(p)
MERGE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_person_availability'})<-[:MENTIONED_IN]-(pm:EntityMention {entity: 'person'})
MATCH (pm)-[:REFERS_TO]->(p:Person {name: pm.value})
MATCH (p)<-[:HAS_PARTICIPANT]-(e:Event)
MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE st.time < timestamp() < et.time
MERGE (cr:CandidateResponse {name: 'InformPersonIsBusy'})-[:ARG_OF]->(p)
MERGE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_person_availability'})<-[:MENTIONED_IN]-(pm:EntityMention {entity: 'person'})
MATCH (i)<-[:MENTIONED_IN]-(tm:TimeMention)
MATCH (pm)-[:REFERS_TO]->(p:Person {name: pm.value})
OPTIONAL MATCH (p)<-[:HAS_PARTICIPANT]-(e:Event)
OPTIONAL MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE st.time < tm.value < et.time
WITH i, p, count(e) as c1, count(st) as c2
WHERE c1=0 or c2=0
MERGE (cr:CandidateResponse {name: 'InformPersonIsAvailable'})-[:ARG_OF]->(p)
MERGE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_person_availability'})<-[:MENTIONED_IN]-(pm:EntityMention {entity: 'person'})
MATCH (i)<-[:MENTIONED_IN]-(tm:TimeMention)
MATCH (pm)-[:REFERS_TO]->(p:Person {name: pm.value})
MATCH (p)<-[:HAS_PARTICIPANT]-(e:Event)
MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE st.time < tm.value < et.time
MERGE (cr:CandidateResponse {name: 'InformPersonIsBusy'})-[:ARG_OF]->(p)
MERGE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_location_availability'})<-[:MENTIONED_IN]-(lm:LocationMention {entity: 'location'})
MATCH (lm)-[:REFERS_TO]->(l:Location {name: lm.value})
OPTIONAL MATCH (l)<-[:HAS_LOCATION]-(e:Event)
OPTIONAL MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE st.time < timestamp() AND timestamp() < et.time
WITH i, l, count(e) as c1, count(st) as c2
WHERE c1=0 or c2=0
MERGE (cr:CandidateResponse {name: 'InformLocationIsAvailable'})-[:ARG_OF]->(l)
MERGE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_location_availability'})<-[:MENTIONED_IN]-(lm:LocationMention {entity: 'location'})
MATCH (lm)-[:REFERS_TO]->(l:Location {name: lm.value})
MATCH (l)<-[:HAS_LOCATION]-(e:Event)
MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE st.time < timestamp() < et.time
MERGE (cr:CandidateResponse {name: 'InformLocationIsTaken'})-[:ARG_OF]->(p)
MERGE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_location_availability'})<-[:MENTIONED_IN]-(lm:LocationMention {entity: 'location'})
MATCH (i)<-[:MENTIONED_IN]-(tm:TimeMention)
MATCH (lm)-[:REFERS_TO]->(l:Location {name: lm.value})
OPTIONAL MATCH (l)<-[:HAS_LOCATION]-(e:Event)
OPTIONAL MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE st.time < tm.value < et.time
WITH i, l, count(e) as c1, count(st) as c2
WHERE c1=0 or c2=0
MERGE (cr:CandidateResponse {name: 'InformLocationIsAvailable'})-[:ARG_OF]->(l)
MERGE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_location_availability'})<-[:MENTIONED_IN]-(lm:LocationMention {entity: 'location'})
MATCH (i)<-[:MENTIONED_IN]-(tm:TimeMention)
MATCH (lm)-[:REFERS_TO]->(l:Location {name: lm.value})
MATCH (l)<-[:HAS_LOCATION]-(e:Event)
MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE st.time < tm.value < et.time
MERGE (cr:CandidateResponse {name: 'InformLocationIsTaken'})-[:ARG_OF]->(l)
MERGE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (ac:CandidateResponse),
(ac)-[e:inferred_from]->(i)
WITH ac, sum(e.util * i.marginal_prob) as util
SET ac.util=util;

MATCH (ac:CandidateResponse)
WITH ac ORDER BY ac.util desc limit 1
CREATE (a:Action)-[:selection]->(ac);"