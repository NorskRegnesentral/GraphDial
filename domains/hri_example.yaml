db_host: tagtog.nr.no
db_port: 7687
zmq_input_port: 5555
zmq_output_port: 5556

inputs:
  - HumanUtterance
  - HumanEngagement
outputs:
  - RobotUtterance
  - RobotAction

initial_state: >
  CREATE (f:Floor {status: 'free'}) ;

update_rules: "
MATCH (i:Intent),
(i)-[e:inferred_from]->(asr:ASRHypothesis)
WITH i, sum(e.condprob * asr.prob) as prob
SET i.marginal_prob=prob;

MATCH (em: EntityMention)-[r:MENTIONED_IN]->(i: Intent)
WHERE degree(em) > 2
MERGE (cr:CandidateResponse {name: 'DisambiguateEntity'})-[:INFERRED_FROM {util: 10}]->(i);

MATCH (em: EntityMention)-[r:MENTIONED_IN]->(i: Intent)
WHERE degree(em) < 2
MERGE (cr:CandidateResponse {name: 'EntityNotFound'})-[:INFERRED_FROM {util: 10}]->(i);

MATCH (i:Intent {name: 'request_person_availability'})<-[:MENTIONED_IN]-(pm:EntityMention {entity: 'person'})
MATCH (pm)-[:REFERS_TO]->(p:Person {name: %s})
OPTIONAL MATCH (p)<-[:HAS_PARTICIPANT]-(e:Event)
OPTIONAL MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE st.time < timestamp() AND timestamp() < et.time
WITH i, p, count(e) as c1, count(st) as c2
WHERE c1=0 or c2=0
MERGE (cr:CandidateResponse {name: 'InformPersonIsAvailable'})-[:ARG_OF]->(p)
MERGE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_person_availability'})<-[:MENTIONED_IN]-(pm:EntityMention {entity: 'person'})
MATCH (pm)-[:REFERS_TO]->(p:Person {name: %s})
MATCH (p)<-[:HAS_PARTICIPANT]-(e:Event)
MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE st.time < timestamp() < et.time
MERGE (cr:CandidateResponse {name: 'InformPersonIsBusy'})-[:ARG_OF]->(p)
MERGE (cr)-[:INFERRED_FROM {util: 1}]->(i)

MATCH (i:Intent {name: 'request_person_availability'})<-[:MENTIONED_IN]-(pm:EntityMention {entity: 'person'})
MATCH (pm)-[:REFERS_TO]->(p:Person)
OPTIONAL MATCH (e:Event)-[hp:HAS_PARTICIPANT]->(p) WITH e, hp WHERE hp IS NULL
CREATE (cr:CandidateResponse {name: 'InformPersonIsAvailable'})<-[:MENTIONED_IN]-(p)
CREATE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_person_availability'})<-[:MENTIONED_IN]-(pm:EntityMention {entity: 'person'})
MATCH (i)<-[:MENTIONED_IN]-(tm:EntityMention {entity: 'time'})
MATCH (pm)-[:REFERS_TO]->(p:Person)<-[:HAS_PARTICIPANT]-(e:Event)
MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE tm.value < st.time
OR tm.value > et.time
CREATE (cr:CandidateResponse {name: 'InformPersonIsAvailable'})<-[:MENTIONED_IN]-(p)
CREATE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_person_availability'})<-[:MENTIONED_IN]-(pm:EntityMention {entity: 'person'})
MATCH (i)<-[:MENTIONED_IN]-(tm:EntityMention {entity: 'time'})
MATCH (pm)-[:REFERS_TO]->(p:Person)<-[:HAS_PARTICIPANT]-(e:Event)
MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE tm.value >= st.time
AND tm.value <= et.time
CREATE (cr:CandidateResponse {name: 'InformPersonIsAvailable'})<-[:MENTIONED_IN]-(p)
CREATE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_location_availability'})<-[:MENTIONED_IN]-(lm:EntityMention {entity: 'location'})
MATCH (lm)-[:REFERS_TO]->(l:Location)<-[:HAS_LOCATION]-(e:Event)
MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE timestamp() < st.time
OR timestamp() > et.time
CREATE (cr:CandidateResponse {name: 'InformLocationIsAvailable'})<-[:MENTIONED_IN]-(l)
CREATE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_location_availability'})<-[:MENTIONED_IN]-(lm:EntityMention {entity: 'location'})
MATCH (lm)-[:REFERS_TO]->(l:Location)<-[:HAS_LOCATION]-(e:Event)
MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE timestamp() >= st.time
AND timestamp() <= et.time
CREATE (cr:CandidateResponse {name: 'InformLocationIsTaken'})<-[:MENTIONED_IN]-(l)
CREATE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_location_availability'})<-[:MENTIONED_IN]-(lm:EntityMention {entity: 'location'})
MATCH (lm)-[:REFERS_TO]->(l:Location)
OPTIONAL MATCH (e:Event)-[hl:HAS_LOCATION]->(l) WITH e, hl WHERE hl IS NULL
CREATE (cr:CandidateResponse {name: 'InformLocationIsAvailable'})<-[:MENTIONED_IN]-(l)
CREATE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_location_availability'})<-[:MENTIONED_IN]-(lm:EntityMention {entity: 'location'})
MATCH (i)<-[:MENTIONED_IN]-(tm:EntityMention {entity: 'time'})
MATCH (lm)-[:REFERS_TO]->(l:Location)<-[:HAS_LOCATION]-(e:Event)
MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE tm.value < st.time
OR tm.value > et.time
CREATE (cr:CandidateResponse {name: 'InformLocationIsAvailable'})<-[:MENTIONED_IN]-(l)
CREATE (cr)-[:INFERRED_FROM {util: 1}]->(i);

MATCH (i:Intent {name: 'request_location_availability'})<-[:MENTIONED_IN]-(lm:EntityMention {entity: 'location'})
MATCH (i)<-[:MENTIONED_IN]-(tm:EntityMention {entity: 'time'})
MATCH (lm)-[:REFERS_TO]->(l:Location)<-[:HAS_LOCATION]-(e:Event)
MATCH (st:Time)<-[:STARTS_AT]-(e)-[:ENDS_AT]->(et:Time)
WHERE tm.value >= st.time
AND tm.value <= et.time
CREATE (cr:CandidateResponse {name: 'InformLocationIsTaken'})<-[:MENTIONED_IN]-(l)
CREATE (cr)-[:INFERRED_FROM {util: 1}]->(i); 

MATCH (ac:CandidateResponse),
(ac)-[e:inferred_from]->(i)
WITH ac, sum(e.util * i.marginal_prob) as util
SET ac.util=util;

MATCH (ac:CandidateResponse)
WITH ac ORDER BY ac.util desc limit 1
CREATE (a:Action)-[:selection]->(ac);"